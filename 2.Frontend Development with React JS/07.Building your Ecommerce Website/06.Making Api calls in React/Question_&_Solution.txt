Watch video 1 and 2 from the following link and answer the following


Ques1. Why should we not connect to database from the frontend itself? What is the problem ?

Ans: Connecting to a database directly from the frontend is a bad practice due to several reasons:

1. Security Risk 
Exposing database credentials (username, password) in the frontend allows hackers to steal them and manipulate your data.
Attackers can directly execute SQL injections and modify/delete sensitive data.

2. Lack of Access Control
The frontend has no control over who accesses the database.
Any user can modify or delete database entries without authentication.

3. Performance Issues
Frontend directly interacting with the database increases server load and slows down performance.
The database may not handle multiple users requesting data at once.

4. Data Validation Issues
Without a backend, anyone can send malformed or invalid data, causing corrupt records in your database.



Ques2. What is the ideal way to connect to databases?

Ans: The correct way is to use a backend server (Node.js, Express, Python Django, etc.). The process is:

Frontend (React, Vue, Angular, etc.)
Sends a request to a backend API (e.g., via fetch()).


Example:

fetch('https://yourapi.com/products')
  .then(response => response.json())
  .then(data => console.log(data));


1. Backend (Node.js, Express, Python, etc.)
	
	Receives the request and processes it.
	
	Connects to the database (MongoDB, MySQL, PostgreSQL).
	
	Retrieves data securely and sends it back as a response.


2. Database (MongoDB, MySQL, Firebase, etc.)
	
	Stores and manages data.

	Only backend servers should interact with the database directly.


Example of Backend API (Node.js + Express connecting to a database)

const express = require('express');
const mysql = require('mysql');
const app = express();

const db = mysql.createConnection({
  host: 'localhost',
  user: 'root',
  password: '',
  database: 'mobilemart'
});

app.get('/products', (req, res) => {
  db.query('SELECT * FROM products', (err, results) => {
    if (err) throw err;
    res.json(results);
  });
});

app.listen(5000, () => console.log('Server running on port 5000'));

This way, the frontend never touches the database directly and stays secure.





Watch video 3 and 4 from above link and answer the following



Ques3. What is default method type of fetch Api ->GET or POST

Ans: The default method type of the fetch() API is GET.

fetch("https://example.com/api/products");

This request is a GET request by default.

If you want to use POST, PUT, or DELETE, you must explicitly specify it:

fetch("https://example.com/api/products", {
  method: "POST",
  body: JSON.stringify({ name: "iPhone 16" }),
  headers: { "Content-Type": "application/json" }
});



Ques4. When I do fetch('https://swapi.dve/api/films') what is the default method type here?

Ans: fetch("https://swapi.dev/api/films");

This request will fetch data from the API using a GET request.



Ques5. What is json? Why do we do response.json() ?

Ans: JSON (JavaScript Object Notation) is a lightweight format used for data exchange between a server and a client.

Example of JSON Data:

{
  "name": "iPhone 16",
  "price": 120000
}

=> Why do we use response.json()?

The fetch() API returns data in raw format (a Response object).
response.json() converts it into a JavaScript object so we can use it easily.
Example:

fetch("https://swapi.dev/api/films")
  .then(response => response.json()) // Converts to JS object
  .then(data => console.log(data)); // Now you can use it

Without response.json(), we cannot access the actual data.



Ques6. What does fetch() return? Why do we need to use 'then'?

Ans: The fetch() function returns a Promise.

A Promise is an asynchronous operation that will complete in the future.
Since fetch() does not return data immediately, we need .then() to handle the response when it's ready.

Example:

const response = fetch("https://swapi.dev/api/films");
console.log(response); // Outputs: Promise { <pending> }

The request is still pending, so we need .then() to handle the response.

Correct way:

fetch("https://swapi.dev/api/films")
  .then(response => response.json()) // Convert response to JSON
  .then(data => console.log(data));  // Use the actual data



Ques7. Why cant we simply write const response. = fetch(url)

Ans: Because fetch(url) returns a Promise, not actual data.

Wrong:

const response = fetch("https://swapi.dev/api/films");
console.log(response); // Outputs: Promise { <pending> }


Correct:

fetch("https://swapi.dev/api/films")
  .then(response => response.json()) // Convert to JSON
  .then(data => console.log(data));  // Use the data

If you want to use async/await, you need to use await because fetch() is asynchronous:


With async/await:

async function getMovies() {
  const response = await fetch("https://swapi.dev/api/films");
  const data = await response.json();
  console.log(data);
}

getMovies();



Deliverable

Since fetch() returns a promise can you write the entire code using async and await? So many then blocks look very bad.It is very simple. Try it by yourself.

[If stuck for very long, please check video 5 from above link]

Push the code to git and upload the commit ID



Solution:
GitHub Repo: https://github.com/MdAbdullahAnwar/E-Commerce-Site 
commit ID: 6efe0aa90e874f7b06583fc8f6694e12156fb6f4