You can refer this resource . But answer everything in your own words. Dont copy paste!!

Ques1. What are props in React? What is the difference between React state and props?

Ans:
Props (short for properties) are read-only inputs passed from parent to child components to configure or render dynamic data.


Example:

function Greeting({ name }) {

 return <h1>Hello, {name}!</h1>;

}


// Usage

<Greeting name="Anwar" />

In React, props are used to pass data into a component from its parent, while state is used to manage data within a component that can change over time.



Ques2. What is prop drilling in React? How to prevent it?

Ans:
Prop drilling means passing data through multiple nested components even if intermediate components don’t need it, just to reach a deeply nested one.

Ways to Prevent Prop Drilling:
Context API (best for small to medium apps)
Redux / Zustand / Jotai (global state libraries)
useReducer + Context for scoped management



Ques3. What are error boundaries in React? How are they different from other components?

Ans:
Error boundaries are React components that catch JavaScript errors in child components and display a fallback UI without crashing the app.

Difference:
Regular components can’t catch render errors.
Error boundaries handle:
render errors
lifecycle errors
constructor errors of child components



Ques4. What are React Hooks? How are they different from normal functions?

Ans:
Hooks are special functions that let you "hook into" React features like state and lifecycle in functional components.

Common Hooks:
useState, useEffect, useContext, useReducer, useRef, etc.
Difference from Normal Functions:
Hooks must follow specific rules.
They allow React to track state and effects.
Normal functions don’t have access to component lifecycle or React state.




Ques5. What are the 2 rules that must be followed while using React Hooks?

Ans:
Only call hooks at the top level (no loops, conditions, or nested functions)
Only call hooks from React components or custom hooks


Why?
React needs to call hooks in the same order on every render to match hook state with correct component. Breaking this causes bugs.



Ques6. When does a functional component re-render? (Lifecycle of functional components)

Ans:
A functional component re-renders when:

Its state changes
Its props change
Its parent re-renders (unless memoized)



Ques7. When does the return statement of a functional component get called?

Ans:
Every time the component renders, which happens on:
State update
Prop update
Parent re-render
React re-evaluates the JSX in the return and compares it (via Virtual DOM diffing) to update the actual DOM.



Ques8. What is the use of useEffect? When does it get called?

Ans:
useEffect allows you to perform side effects like:

Fetching data
Subscribing to events
Setting up timers
Called when:
The component mounts (initial render)
Dependencies in the array change
Cleanup happens before unmount or before the next effect



Ques9. What are the 2 arguments of useEffect? Explain with example.

Ans:
Syntax:
useEffect(callback, dependencyArray);

callback: Function to run (can return a cleanup function)

dependencyArray: Controls when effect runs



Example:

useEffect(() => {

 const timer = setInterval(() => {

  console.log("Running effect...");

 }, 1000);

 return () => clearInterval(timer);

}, []);
